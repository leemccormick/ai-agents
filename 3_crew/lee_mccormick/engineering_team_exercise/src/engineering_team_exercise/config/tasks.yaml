analyst_task:
  description: >
    Use SerperDevTool to research and identify the top 3 key features for the given {business_idea}.
    For each feature, return a name (in snake_case format) and a short one-paragraph description.
  expected_output: >
    A JSON object with a `features` key, mapping to a list of exactly 3 items.
    Each item should have:
      - `name`: a short, lowercase, snake_case identifier
      - `description`: a concise description of what the feature does
    Example:
    {
      "features": [
        { "name": "order_cart", "description": "Manages adding/removing items and calculating totals." },
        { "name": "payment", "description": "Handles payment submission and receipts." },
        { "name": "inventory", "description": "Tracks item stock and availability." }
      ]
    }
  agent: business_analyst
  output_file: output/features.json

design_task:
  description: >
    Read the list of features from the JSON file `output/features.json` generated by the business analyst.
    For each feature:
      - Define a Python module name (use the `name` field from the JSON)
      - Design 1 or more classes for the module. For each class, include:
          - Class name
          - Responsibility (1-2 sentence description)
          - Method names with signatures
          - Purpose of each method
    The goal is to help backend engineers build this in Python.
    Combine all module designs into a single Markdown document.
  expected_output: >
    A well-structured Markdown document that includes 3 sections â€” one per module.
    Each section must contain the module name, class names, responsibilities, and method breakdowns.
    File: output/technical_design.md
  agent: engineering_lead
  context:
    - analyst_task
  output_file: output/technical_design.md

code_task:
  description: >
    You are a backend engineer who must implement Python modules based on the technical design.
    
    STEP 1: Read the file `output/features.json` to get the list of module names.
    STEP 2: Read the file `output/technical_design.md` to understand the design for each module.
    STEP 3: For EACH module in the features list:
      - Extract the module design from the technical design document
      - Implement all classes and methods as specified
      - Use the FileWriterTool to save each module as a separate Python file
      - File path format: `output/[module_name]/[module_name].py`
      - Create the directory if it doesn't exist
    
    IMPORTANT IMPLEMENTATION RULES:
    - Write clean, executable Python code only
    - Include proper class definitions and method implementations
    - Add basic error handling where appropriate
    - Make methods functional, not just stubs
    - Ensure each file is self-contained and importable
    
    Use FileWriterTool for each module file. Do NOT output code in your response - save it directly to files.

  expected_output: >
    Successfully create separate Python files for each module:
    - Each file saved to `output/[module_name]/[module_name].py`
    - All classes and methods implemented as designed
    - Files are executable and ready for testing
    
    Provide a summary report listing:
    - Module names processed
    - Files created with their paths
    - Brief description of classes implemented in each file

  agent: backend_engineer
  context:
    - design_task
    - analyst_task

frontend_task:
  description: >
    Write a Gradio-based UI in `app.py` that demonstrates the functionality of each backend module.
    
    STEP 1: Read `output/features.json` to get the list of modules
    STEP 2: For each module, import it from its respective directory
    STEP 3: Create a Gradio interface that demonstrates key functionality
    
    The UI should include:
      - A clear layout with section headers per feature/module
      - Inputs and outputs for key methods from each module
      - Use of Gradio components like textboxes, dropdowns, buttons, etc.
    
    IMPORTANT: Output ONLY the raw Python code without any markdown formatting, code block delimiters, or backticks.
    The output should be valid Python code that can be directly saved to a file and executed.
  expected_output: >
    A single `app.py` file that integrates all backend modules and runs a basic Gradio app.
    The UI should be organized by feature/module.
    File: output/app.py

  agent: frontend_engineer
  context:
    - code_task
  output_file: output/app.py

test_task:
  description: >
    Write comprehensive unit tests for each backend module.
    
    STEP 1: Read `output/features.json` to get the list of modules
    STEP 2: For each module:
      - Import the module from its directory
      - Write unit tests covering all classes and methods
      - Use FileWriterTool to save test file as `output/[module_name]/test_[module_name].py`
    
    Each test file should:
      - Import the target module properly
      - Test all public methods of each class
      - Include edge cases and error conditions
      - Use unittest framework

  expected_output: >
    Create unit test files for each module:
    - Files saved as `output/[module_name]/test_[module_name].py`
    - Comprehensive test coverage for all classes and methods
    - Tests are executable with unittest or pytest
    
    Provide a summary of test files created and test coverage.

  agent: test_engineer
  context:
    - code_task